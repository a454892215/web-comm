<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button onclick="alert('啦啦啦')">点击我</button>
    <span title="title"> 标题</span>
    <!--  data-id自定义的属性 -->
    <a href="" data-uName="abc"></a>
    <script>

    /**
    1. 字面量创建对象
        let obj{
            uname : 'TOM'
            age : 22
            sum : function(){}
        }
        访问属性:
        1. obj.uname
        2. obj['uname']
        3.变量属性
            for(let key in obj){
                console.log(obj[key])
            }
            
    2. 构造函数
        1. 内置构造函数： 
            let obj = new Object(); // 构造函数如果没有参数可以省略小括号 let obj = new Object
            obj.uname = 'tom'
            obj.age = 22
            obj.add = function(){}
            let obj= new Object({uname : 'sam', age : 33})
        2. 自定义构造函数：
            function Persion(uname, age, sex){
                this.uname = uname // 实例成员
                this.age = age
                this.sex = sex
                this.eat =function(){}
            }
            Persion.skin = 2 // 静态成员
                    
        3. instanceof 判断一个对象是否另一个构造函数的实例对象
           constructor
            function A(){}
            function B(){}
            let obj = new B()
            console.log(obj instanceof B)
            console.log(obj.constructor) 指向构造函数本身

        4. 数据类型：
               简单数据类型：字符串， 数字， 布尔， undefined， null
               复杂数据类型：对象（如数组）    
        5. 值传递和引用传递
           简单数据值传递，复杂数据引用传递
        6. 推荐使用字面量方式创建对象，而不是Object构造函数
           Object.assign(obj) 静态方法创建新对象 ？
           Object.keys(obj) 静态方法获取对象中的所有属性 ？
           Object.values(obj) 静态方法获取对象中的所有属性值  ？  
        7.数组
          let arr = [1, 2, 3]    推荐使用
          let arr = new Array(1, 2, 3)
          数组实例函数：forEach, filter,map join,concat, sort, indexOf, reverse
          静态函数，from伪数组转成数组
          let str = arr.join('-') 数组转字符串
          let re = arr.sort(function(a, b){return a b- b;}) // 正序排序
          arr.forEach(function(item, index, obj)){} // obj数组对象本身
        8.正则构造函数和正则字面量
           let reg = /abv/
           let reg = new RegExp(/abv/);   
        9. 包装类型
           String
           Number Number.parseInt(v) Number.parseFloat(v)
           Boolean   
        10. 字符串函数
            "abc".slice(start, end) 字符串截取
            "abc".toUpperCase();
        11. 公共函数：toString()
        12. prototype（原型对象）: https://zhuanlan.zhihu.com/p/537600424
                给已存在的对象添加新的属性或方法
                给对象的构造函数添加属性或方法
                使用 prototype 属性就可以给对象的构造函数添加新的属性
                使用 prototype 的新增函数，不能被对象的新增函数覆盖，只能再使用prototype覆盖
             JavaScript中获取原型的方式有3种：
                 1. 通过构造函数的 prototype 属性  
                 2. 通过Object.getPrototypeOf(obj)方法。
                 3. 通过对象的__proto__: obj.__proto__

             通过原型实现继承：把某实例对象赋值给原型对象 (Chinese.prototype = new Chinese）
             function Person(){
                this.name = "zhaoran";
             }
             // 使用构造函数的prototype属性给构造函数新增属性和函数
             Person.prototype.name = "bing";
             Person.prototype.say = function(){}
             var John = new Person();
             alert(John.name);  // "zhaoran"
             alert(John.say()); // "hello world"     

             扩展数组的函数,：
                 Array.prototype.sum = function(){} // 给数组增加sum函数
        13. this的指向
            1. 普通函数的this指向调用者
                function fn(){}
            2. 构造函数的this 指向实例化对象，调用者
                function Person(uname, age){
                    this.uname = uname;
                    this.age = age;
                }
            3.事件处理函数指向事件源：
                document.addEventListener('click', function(){}); 
            4.箭头函数的this是上一级作用域的this       
        14. 严格模式： "use strict" 
                 1.变量必须定义再使用
                 2.普通函数总的this指向undefined
                 3.函数的形参不准重名.  
        15. 修改this指向          
                1. call:  funName.call(obj, p1, p2...); 函数中的this指向obj
                2. apply: funName.apply(obj, [p1, p2]); 函数中的this指向obj
                3. bind： funName.bind(obj, p1, p2...)(); 函数中的this指向obj,需要加上(),才会调用  
        }             

     */

    </script>
    <!--外部js  -->
    <!-- <script src="./fileName"></script> -->
</body>
<!-- js脚本写在HTML标签执行后 -->

</html>