<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button onclick="alert('啦啦啦')">点击我</button>
    <span title="title"> 标题</span>
    <!--  data-id自定义的属性 -->
    <a href="" data-uName="abc"></a>
    <script>

        /**
        //  正则表达式：/正则表达式主体/修饰符(可选)： var patt = /runoob/i
        test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。
               var patt = /e/;
               patt.test("The best things in life are free!");
        exec() 方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 
               /e/.exec("The best things in life are free!");
        在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。       
        search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。
                 var str = "Visit Runoob!"; 
                 var n = str.search(/Runoob/i);    
        replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。   
                 str.replace(/microsoft/i,"Runoob");      、
        
        javascript变量的作用域：
        闭包：闭包使用多了。 容易导致内存泄露。    
        预解析：（预解析+全局变量的声明会造成很复杂难解的逻辑）
            变量： 声明的变量，把变量定义的语法提升到当前作用域最前面，不赋值
            函数： 带名字的函数，把函数定义的语法提升到当前作用域最前面，不调用
        动态参数：
        function add(){
            函数内部有个特殊的参数，arguments 用于接收所有的实参
            for(let i = 0; i< arguments.length; i ++){
                console.log("${arguments[i]}")
            }
        }  
        add(1,2,3,4)   

        剩余参数：  ...
        function add(a, b, ...c){
             for(let i = 0; i< c.length; i ++){
                console.log("${c[i]}")
            }
        }  
        add(1, 2, 3, 4, 5, 6)   

        箭头函数：
            let fn = (a, b) => {
                return a + b
            }
            fn(1, 2)
            1. 如果箭头函数的参数只有一个可以省略小括号：
            let fn = a => {
                return a * a
            }
            2. 如果箭头函数只有一行代码， 可以省略大括号(大括号省略了，return也可以省略)：
            let fn = a => return a * a;
            let fn = a => a * a;
            3. 箭头函数不存在预解析，必须先定义再调用
            4. j箭头函数不存在argments
            5. 箭头函数不存在this,this指向上级作用域的this

            解构语法：
                let aar = [1, 2, 3]
                let[a, b, c] = aar
                console.log(a)
                console.log(b)


         */

    </script>
    <!--外部js  -->
    <!-- <script src="./fileName"></script> -->
</body>
<!-- js脚本写在HTML标签执行后 -->

</html>